### 소수 구하기

> **소수 (prime number)**
> 
- 1과 자기 자신 외에 약수가 존재하지 않는 수

> **에라토스테네스의 체 원리**
> 
- 소수를 구하는 대표적인 판별법으로는 에라토스테네스의 체를 들 수 있다.
1. 구하고자 하는 소수의 범위 만큼 1차원 배열을 생성한다.
2. 2부터 시작하고 현재 숫자가 지워지지 않을 때는 현재 선택된 숫자의 배수에 해당하는 수를 배열에서 끝까지 탐색하면서 지운다. 이 때 처음으로 선택된 숫자는 지우지 않는다. ➡️ 이게 바로 소수 ! 
3. 배열의 끝까지 2️⃣를 반복한 후 배열에서 남아 있는 모든 수를 출력한다. 
<img width="782" alt="Screenshot_2023-07-27_at_14 58 57" src="https://github.com/StopSoo/Stopsoo/assets/114139700/5f04cc0c-298e-43b4-80ab-f3afc0f76749">
<img width="800" alt="Untitled" src="https://github.com/StopSoo/Stopsoo/assets/114139700/8879786d-1f59-4404-9c47-1b0e533aa0d3">


💡 **에라토스테네스의 체를 사용할 때 시간 복잡도는 ?**
>
일반적으로 에라토스테네스의 체를 구현하려면 이중 for문을 사용하므로 시간 복잡도가 $O(n^2)$  정도라고 판단할 수 있다. 하지만 실제 시간 복잡도는 최적화의 정도에 따라 다르겠지만, 일반적으로 $O(nlog(logn))$이다. 그 이유는 배수를 삭제하는 연산으로 실제 구현에서 바깥쪽 for문을 생략하는 경우가 빈번하게 발생하기 때문이다. 이러한 이유 때문에 에라토스테네스의 체 기법은 현재에도 코딩 테스트에서 소수를 구하는 일반적인 방법으로 통용되고 있다.

### 오일러 피

> **오일러 피**
> 
- 오일러 피 함수 $P[N]$의 정의는 1부터 N까지 범위에서 N과 서로소인 자연수의 개수를 뜻한다.
- 원리를 알지 못 하면 아예 풀기가 어렵기 때문에 원리를 이해할 것 !

> **오일러 피 함수의 원리**
> 
- 오일러 피 함수의 원리는 에라토스테네스의 체와 비슷하다.
1. 구하고자 하는 오일러 피의 범위 만큼 배열을 자기 자신의 인덱스 값으로 초기화한다.
2. 2부터 시작해 현재 배열의 값과 인덱스가 같으면 (= 소수일 때) 현재 선택된 숫자(K)의 배수에 해당하는 수를 배열에 끝까지 탐색하며 $P[i] = P[i] - P[i] /K$ 연산을 수행한다. (i는 K의 배수)
3. 배열의 끝까지 2️⃣를 반복하며 오일러 피 함수를 완성한다. 

<img width="811" alt="Screenshot_2023-07-27_at_15 09 12" src="https://github.com/StopSoo/Stopsoo/assets/114139700/323cde3e-cbf2-446a-80ea-07181d95cd2f">
<img width="811" alt="Screenshot_2023-07-27_at_15 11 40" src="https://github.com/StopSoo/Stopsoo/assets/114139700/2e4fe433-efdd-4858-8639-305c221db178">

- 위 과정을 배열이 끝날 때까지 반복한다.


💡 **수학적으로 오일러 피 함수 이해하기**
>
- 초기 상태  $\phi$  (6) = 6 ➡ 서로소가 될 수 있는 후보의 개수로 초기화 (1, 2, 3, 4, 5, 6)
- 2의 배수로 인한 탈락 ➡ $\phi$  (6) = 6 - (6 / 2) = 3 (1, 3, 5)
- 3의 배수로 인한 탈락 ➡ $\phi$  (6) = 3 - (3 / 3) = 2 (1, 5)

이 때 후보에서 삭제하는 기준을 6이 아닌 업데이트된 3으로 진행하는 이유는 3의 배수 중 2의 배수인 수는, 즉 3과 2의 공배수는 2의 배수에서 이미 삭제됐기 때문에 중복 삭제를 막기 위함입니다. 이 예시에서는 6을 중복 삭제하지 않기 위한 것일 것이고, 최종적으로 $\phi$(6) = 2가 된다. 이 때 2의 의미는 숫자 6과 6 이하의 숫자 중 서로소가 되는 개수가 2개라는 뜻이 된다.

### 유클리드 호제법

> **유클리드 호제법**
> 
- 두 수의 최대 공약수를 구하는 알고리즘
- 일반적으로 최대 공약수를 구하는 방법은 소인수 분해를 이용한 공통된 소수들의 곱으로 표현할 수 있지만 유클리드 호제법은 좀 더 간단한 방법을 제시한다.

> **MOD 연산으로 구현하는 유클리드 호제법**
> 
- MOD 연산 : 두 값을 나눈 나머지를 구하는 연산
1. 큰 수를 작은 수로 나누는 MOD 연산을 수행한다. 
2. 앞 단계에서의 작은 수와 MOD 연산 결괏값(나머지)으로 MOD 연산을 수행한다.
3. 단계 2️⃣를 반복하다가 나머지가 0이 되는 순간의 작은 수를 최대 공약수로 선택한다. 

<img width="679" alt="Screenshot_2023-07-27_at_15 31 01" src="https://github.com/StopSoo/Stopsoo/assets/114139700/353898b4-a753-402f-849a-f2b579e7f4c2">

- 실제로 유클리드 호제법은 재귀 함수로 구현한다 !!

### [유클리드 호제법 실전 문제] 최소 공배수 구하기 (백준 1934)
>
- 최소 공배수는 A와 B가 주어졌을 때 **‘A * B / 최대 공약수’** 를 계산해 구할 수 있다. 그래서 이 문제는 유클리드 호제법을 이용해 최대 공약수를 구한 후 두 수의 곱에서 최대 공약수를 나눠주는 것으로 해결할 수 있다.
