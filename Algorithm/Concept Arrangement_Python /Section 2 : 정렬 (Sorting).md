### 버블 정렬 (Bubble Sort)

> **정렬 알고리즘의 종류**
> 
- 버블 정렬 : 데이터의 인접 요소끼리 비교하고, swap 연산을 수행하며 정렬하는 방식
- 선택 정렬 : 대상에서 가장 크거나 작은 데이터를 찾아가 선택을 반복하면서 정렬하는 방식
- 삽입 정렬 : 대상을 선택해 정렬된 영역에서 선택 데이터의 적절한 위치를 찾아 삽입하면서 정렬하는 방식
- 퀵 정렬 : pivot 값을 선정해 해당 값을 기준으로 정렬하는 방식
- 병합 정렬 : 이미 정렬된 부분 집합들을 효율적으로 병합해 전체를 정렬하는 방식
- 기수 정렬 : 데이터의 자릿수를 바탕으로 비교해 데이터를 정렬하는 방식

> **버블 정렬**
> 
- 두 인접한 데이터의 크기를 비교해 정렬하는 방법
- 시간 복잡도는 $O(n^2)$, 다른 정렬 알고리즘보다 속도가 느린 편
    - 한 번 루프를 돌 때 n번의 비교를 하는데, 총 n번의 루프를 돌게 되므로 위와 같은 시간 복잡도가 나온다.
<img width="781" alt="Screenshot 2023-07-22 at 16 44 06" src="https://github.com/StopSoo/Stopsoo/assets/114139700/810f9084-8f3b-4578-9031-9240341f231f">


> **버블 정렬 과정**
> 
1. 비교 연산이 필요한 루프 범위를 설정한다.
2. 인접한 데이터 값을 비교한다.
3. swap 조건에 부합하면 swap 연산을 수행한다.
4. 루프 범위가 끝날 때까지 2~3을 반복한다. 
5. 정렬 영역을 설정한다. 다음 루프를 실행할 때는 이 영역을 제외한다.
6. 비교 대상이 없을 때까지 1~5를 반복한다.

💡 만약 특정한 루프의 전체 영역에서 swap이 한 번도 발생하지 않았다면, 그 영역 뒤에 있는 데이터가 모두 정렬됐다는 뜻이므로 프로세스를 종료해도 된다.


### 선택 정렬 (Selection Sort)

> **선택 정렬**
> 
- 최대나 최소 데이터를 데이터가 나열된 순으로 찾아가며 선택하는 방법
- 구현 방법이 복잡하고, 시간 복잡도도 $O(n^2)$로 효율적이지는 않지만 원리를 알아두는 것이 좋다.
    - 최솟값을 찾는 데 n 만큼 탐색, 이 루프를 n번 반복하므로 위와 같은 시간 복잡도가 나온다.

> **선택 정렬의 핵심 이론**
> 
- 최솟값 또는 최댓값을 찾고, 남은 정렬 부분의 가장 앞에 있는 데이터와 swap하는 것이 선택 정렬의 핵심이다.

<img width="492" alt="Screenshot 2023-07-22 at 16 57 43" src="https://github.com/StopSoo/Stopsoo/assets/114139700/ee53cc90-b27d-4739-8637-7f78848ce8bb">

> **선택 정렬 과정**
> 
1. 남은 정렬 부분에서 최솟값 또는 최댓값을 찾는다.
2. 남은 정렬 부분에서 가장 앞에 있는 데이터와 선택된 데이터를 swap한다.
3. 가장 앞에 있는 데이터의 위치를 변경해(index++) 남은 정렬 부분의 범위를 축소한다.
4. 전체 데이터 크기 만큼 index가 커질 때까지, 즉 남은 정렬 부분이 없을 때까지 반복한다. 

### 삽입 정렬 (Insertion Sort)

> **삽입 정렬**
> 
- 이미 정렬된 데이터 범위에 정렬되지 않은 데이터를 적절한 위치에 삽입시켜 정렬하는 방식
- 시간 복잡도는 $O(n^2)$로 느린 편이지만 구현하기가 쉽다.

> **삽입 정렬의 핵심 이론**
> 
- 선택 데이터를 현재 정렬된 데이터 범위 내에서 적절한 위치에 삽입하는 것이 삽입 정렬의 핵심이다.

<img width="779" alt="Screenshot 2023-07-22 at 17 10 23" src="https://github.com/StopSoo/Stopsoo/assets/114139700/cbfbeac9-e2ec-49c6-b2f9-d84b4b066c9f">

> **삽입 정렬 과정**
> 
1. 현재 index에 있는 데이터 값을 선택한다.
2. 현재 선택한 데이터가 정렬된 데이터 범위에 삽입될 위치를 탐색한다.
3. 삽입 위치부터 index에 있는 위치까지 shift 연산을 수행한다.
4. 삽입 위치에 현재 선택한 데이터를 삽입하고 index++ 연산을 수행한다.
5. 전체 데이터의 크기 만큼 index가 커질 때까지, 즉 선택할 데이터가 없을 때까지 반복한다. 
>
💡 적절한 삽입 위치를 탐색하는 부분에서 이진 탐색(binary search) 등과 같은 탐색 알고리즘을 사용하면 시간 복잡도를 줄일 수 있다. 
>
이진 탐색을 사용하지 않을 경우 :  $O(n)$  
>
이진 탐색을 사용할 경우 :  $O(log n)$  
>


### [삽입 정렬 실전 문제] ATM 인출시간 계산하기 (백준 11399)

💡 이 문제의 포인트는 입력 받은 배열을 오름차순으로 정렬해야 한다는 것 ! 
>
➡️ 모든 사람이 가장 빠른 시간에 인출하는 방법을 그리디 방식으로 해결해보자. 앞에 있는 사람 중 인출 시간이 가장 적게 걸리는 사람이 먼저 인출할 수 있도록 순서를 정하는 것이 곧 그리디 방식 !
>
💡 N의 최댓값이 1000이고 시간 제한이 1초이므로, 시간 복잡도가 $O(n^2)$  이하인 정렬 알고리즘 중 아무거나 사용해도 된다 !
>
<img width="791" alt="Screenshot 2023-07-23 at 16 49 20" src="https://github.com/StopSoo/Stopsoo/assets/114139700/6b31dcfc-2f58-46be-8e11-7a28d749c652">

### 퀵 정렬 (Quick Sort)

> **퀵 정렬**
> 
- 기준 값(pivot)을 선정해 해당 값보다 작은 데이터와 큰 데이터로 분류하는 것을 반복해 정렬하는 알고리즘
- 기준 값이 어떻게 선정되는지가 시간 복잡도에 많은 영향을 미친다.
- 평균 시간 복잡도는 $O(nlogn)$이며, 최악의 경우에는 시간 복잡도가 $O(n^2)$가 된다.

> **퀵 정렬의 핵심 이론**
> 

<img width="440" alt="Screenshot 2023-07-24 at 15 32 12" src="https://github.com/StopSoo/Stopsoo/assets/114139700/c2899aa3-f7c2-4220-942c-26d86f976710">

> **퀵 정렬 과정**
> 
1. 데이터를 분할하는 pivot을 설정한다. (위 그림의 경우 가장 오른쪽 끝을 pivot으로 설정)
2. pivot을 기준으로 다음 a~e 과정을 거쳐 데이터를 2개의 집합으로 분리한다.
    1. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start를 오른쪽으로 1칸 이동한다.
    2. end가 가리키는 데이터가 pivot이 가리키는 데이터보다 크면 end를 왼쪽으로 1칸 이동한다.
    3. start가 가리키는 데이터가 pivot이 가리키는 데이터보다 크고, end가 가리키는 데이터가 pivot이 가리키는 데이터보다 작으면 start, end가 가리키는 데이터를 swap하고 start는 오른쪽, end는 왼쪽으로 1칸씩 이동한다.
    4. start와 end가 만날 때까지 a~c를 반복한다.
    5. start와 end가 만나면 만난 지점에서 가리키는 데이터와 pivot이 가리키는 데이터를 비교하여 pivot이 가리키는 데이터가 크면 만난 지점의 오른쪽에, 작으면 만난 지점의 왼쪽에 pivot이 가리키는 데이터를 삽입한다.
3. 분리 집합에서 각각 다시 pivot을 선정한다.
4. 분리 집합이 1개 이하가 될 때까지 과정 1~3을 반복한다.

- 퀵 정렬의 시간 복잡도는 비교적 준수하므로 코딩 테스트에서도 종종 응용한다. 재귀 함수의 형태로 구현해 볼 것 !!

### 병합 정렬 (Merge Sort)

> **병합 정렬**
> 
- 분할 정복(divide and conquer) 방식을 사용해 데이터를 분할하고 분할한 집합을 정렬하며 합치는 알고리즘
- 병합 정렬의 시간 복잡도는 $O(nlogn)$이다.
    - 한 번 데이터에 접근할 때 $n$번의 access가 필요하고, 그 $n$  번의 access가 $log n$만큼 일어나기 때문 !

<img width="689" alt="Screenshot 2023-07-25 at 15 21 55" src="https://github.com/StopSoo/Stopsoo/assets/114139700/b2c04576-d9c3-41c2-9dc4-6179443caced">

>
두 set씩 합치면서 한 set의 크기가 커지고, 각각의 set는 정렬된 상태가 된다.

💡 **병합 정렬 수행 방식**
>
최초에는 8개의 그룹으로 나뉜다. 이 상태에서 2개의 그룹을 합치며 오름차순으로 정렬한다. 그 결과 (32, 42), (24, 60), (5, 15), (45, 90)이 된다. 이어서 2개씩 그룹을 합치며 다시 오름차순 정렬한다. 그 결과 (24, 32, 42, 60), (5, 15, 45, 90)이 된다. 이런 방식으로 병합 정렬을 거치면 전체를 오름차순으로 정렬할 수 있다. 
>
➡️ 여기서 2개의 그룹을 병합하는 원리가 중요하다 ! 🔥


> **2개의 그룹을 병합하는 과정 ⭐️**
> 
- 투 포인터 개념을 사용하여 왼쪽, 오른쪽 그룹을 병합한다. 왼쪽 포인터와 오른쪽 포인터의 값을 비교하여 작은 값을 결과 배열에 추가(➡️오름차순이므로)하고 포인터를 오른쪽으로 1칸 이동시킨다. 이 방식은 여러 문제에서 응용하므로 반드시 숙지하는 것이 좋다.

<img width="744" alt="Screenshot 2023-07-25 at 15 36 04" src="https://github.com/StopSoo/Stopsoo/assets/114139700/8ce5e3a4-eac2-453f-8c4f-98a3d8a8caba">

### [병합 정렬 실전 문제] 버블 정렬 프로그램 2 (백준 1517) ⭐️

<img width="774" alt="Screenshot 2023-07-25 at 16 25 09" src="https://github.com/StopSoo/Stopsoo/assets/114139700/ea33b50c-6e67-42b4-a8a5-95453ce9c89e">

💡 N이 최대 500,000이므로 절대 $N^2$  의 시간 복잡도를 가진 알고리즘으로는 풀 수 없다.
따라서 버블 정렬의 시간 복잡도는 $N^2$  이므로 버블 정렬로는 풀 수 없다.  
그러므로 $O(nlogn)$  의 시간 복잡도를 가지는 병합 정렬을 사용해야 한다.


### 기수 정렬 (Radix Sort)

> **기수 정렬**
> 
- 값을 비교하지 않는 특이한 정렬이다. 값을 놓고 비교할 자릿수를 정한 다음 해당 자릿수만 비교한다.
- 기수 정렬의 시간 복잡도는 $O(kn)$으로, 여기서 $k$는 데이터의 자릿수를 말한다.
- 시간 복잡도가 가장 짧은 정렬이다. 만약 코딩 테스트에서 정렬해야 하는 데이터의 개수가 너무 많을 경우 기수 정렬 알고리즘을 활용하는 것도 좋다 !

> **기수 정렬의 핵심 이론**
> 
- 10개의 큐를 이용하고, 각 큐는 값의 자릿수를 대표한다.
<img width="736" alt="Screenshot 2023-07-25 at 16 00 43" src="https://github.com/StopSoo/Stopsoo/assets/114139700/73f52dca-6f33-461a-a42c-9e55dc52cf45">
<img width="736" alt="Screenshot 2023-07-25 at 16 02 11" src="https://github.com/StopSoo/Stopsoo/assets/114139700/6808b2b2-66c9-4913-a829-eb10cd0bc728">

