### 그래프 기본

> **유니온 파인드**
> 
- 그래프의 사이클이 생성되는지 판별하는 알고리즘

> **위상 정렬**
> 
- 조건 1) 사이클이 없어야 한다.
- 조건 2) 방향이 있는 그래프여야 한다.
- 위 조건에 해당하는 그래프를 정렬하는 알고리즘.
- 정렬 결과가 유일하지 않다.
- Ex> 수강 신청 (선/후수 과목), 게임 빌드 오더

> **최단 거리 알고리즘**
> 
> - **다익스트라**
>     - 고정된 시작점에서 다른 모든 노드로 가는 최단 거리를 구하는 알고리즘.
>     - 단, 음수 간선은 존재할 수 없다. ➡️ 간선의 가중치는 양수여야 한다.
> - **벨만-포드**
>     - 다익스트라 알고리즘과 다른 조건은 같으나, 음수 간선이 존재할 수 있다는 점에서 다익스트라 알고리즘과 다르다.
>     - 음수 사이클이 있는지 체크하는 문제에서 많이 사용된다.
> - **플로이드-워셜**
>     - 고정된 시작점이 없이, 모든 노드에 대해 최단 거리를 구할 수 있는 알고리즘이다.
>     - 시간 복잡도가 좋지 않다.
>     - Ex> 모든 도시를 연결하는 최단 거리를 구하시오. ➡️ n이 작고 시작점이 정해져 있지 않은 문제에 사용하면 좋다 !

> **최소 신장 트리 (Minimum Spanning Tree)**
> 
- 최소의 비용(가중치)으로 모든 노드들을 연결하는 알고리즘
- 사이클에서 하나의 간선을 제거하더라도 연결된 모든 노드에 접근 가능하기 때문에, 사이클이 존재할 수 없다.
- 따라서 최소 신장 트리 알고리즘을 구현할 때 사이클이 생성되는지 확인하는 유니온 파인드 알고리즘을 이용한다.

### 그래프의 표현

> **그래프를 구현하는 3가지 방법**
> 
1. **에지 리스트 (Edge List)**
- 가중치 없는 그래프
> 


<img width="797" alt="Screenshot 2023-08-03 at 1 27 55" src="https://github.com/StopSoo/Stopsoo/assets/114139700/f4ffc1f7-7a3f-4059-a769-281f0e699114">

> 
    - 1에서 2로 뻗어나가는 에지는 [1, 2]와 같이 표현한다. 이처럼 방향이 있는 그래프는 순서에 맞게 노드를 배열에 저장하는 방식으로 표현한다.
    - 여기서는 방향이 있는 그래프를 예로 들었다. 만약 방향이 없는 그래프라면 [1, 2]와 [2, 1]은 같은 표현일 것이다. 
    - 에지 리스트는 에지를 중심으로 그래프를 표현한다.
- 가중치 있는 그래프
<img width="827" alt="Screenshot 2023-08-03 at 1 31 42" src="https://github.com/StopSoo/Stopsoo/assets/114139700/39190d3d-7e9c-47e0-90dc-ac2d96395451">

> 
    - S(시작), E(끝), V(가중치) 이렇게 3개의 행을 가진 배열에 값을 저장한다. 그래서 예를 들어 1에서 2로 향하는 가중치가 8인 노드는 이제는 [1, 2, 8]과 같이 표현한다. 이렇게 에지 리스트는 구현하기 쉽지만, 특정 노드와 관련되어 있는 에지를 탐색하기는 쉽지 않다. 
    - 에지 리스트는 벨만 포드나 크루스칼(MST) 알고리즘에 사용하며, 노드 중심 알고리즘에는 잘 사용하지 않는다. ➡️ 벨만 포드와 크루스칼 알고리즘은 노드에 의존하지 않기 때문에 에지 리스트를 사용한다.

2. **인접 행렬 (Adjacency Matrix)**
- 인접 행렬은 2차원 배열을 자료구조로 이용하여 그래프를 표현한다.
    - 사용하지 않는 공간까지 탐색해야 한다는 단점이 있다.
- 인접 행렬은 에지 리스트와 다르게 노드 중심으로 그래프를 표현한다.
- 가중치 없는 그래프
<img width="827" alt="Screenshot 2023-08-03 at 1 36 44" src="https://github.com/StopSoo/Stopsoo/assets/114139700/683a9e8c-e569-4015-b453-11fcefd6ab00">

>  
    - 가중치가 없기 때문에 배열에 들어가는 값을 1로 설정 !
    
- 가중치 있는 그래프
<img width="760" alt="Screenshot 2023-08-03 at 1 40 48" src="https://github.com/StopSoo/Stopsoo/assets/114139700/74665205-40e7-451f-8b11-bbee628555f5">

>
    - 1 대신 가중치를 배열 해당 칸에 적어준다.
    - 노드와 관련되어 있는 에지를 탐색하려면 N번 접근해야 하므로 노드 개수에 비해 에지가 적을 때는 공간 효율성이 떨어진다. ➡️ 시간 복잡도도 좋지 않다.
    - 노드 개수가 많은 경우 아예 2차원 배열 선언 자체를 할 수 없는 결함도 존재한다.
    - 따라서 인접 행렬은 노드 개수에 따라 사용 여부를 적절하게 판단하는 능력도 필요로 한다.

3. **인접 리스트 (Adjacency List) ⭐️**
- 가중치 없는 그래프
    - Ex> ArrayList<integer>[5]로 선언
    1️⃣ 가중치가 없다.
    2️⃣ ArrayList의 배열이다. ➡️ ArrayList는 Array와 다르게 가변적 !
<img width="758" alt="Untitled" src="https://github.com/StopSoo/Stopsoo/assets/114139700/c4abd663-8feb-4a06-be5a-4e554ccf52fa">


- 가중치 있는 그래프 ⭐️⭐️
<img width="785" alt="Screenshot 2023-08-03 at 14 33 23" src="https://github.com/StopSoo/Stopsoo/assets/114139700/d08578f7-f5ee-490b-bedc-060ad4eead78">

>
    - 여기서 Node는 프로그래머가 직접 만들어야 할 class 객체이다. 
    - 그래프 구현이 복잡한 편이다.
    - 하지만 노드와 연결되어 있는 에지를 탐색하는 시간 복잡도는 낮은 편으로 매우 뛰어나며, 노드 개수가 커도 공간 효율이 좋아 메모리 초과 에러도 발생하지 않는다.
    - 이런 장점들로 인해 실제 코딩 테스트에서는 인접 리스트를 이용한 그래프 구현을 선호한다.

### 유니온 파인드 (Union-Find)

> **유니온 파인드**
> 
- 여러 노드가 있을 때 특정 2개의 노드를 연결해 1개의 집합으로 묶는 **union 연산**과 두 노드가 같은 집합에 속해 있는지를 확인하는 **find 연산**으로 구성되어 있다.

<aside>
  
💡  **union, find 연산**

>
  
**- union 연산**: 각 노드가 속한 집합을 1개로 합치는 연산이다. 노드 a, b가 a $\in$ A, b $\in$ B일 때 union(a, b)는 A U B를 말한다. 

>

**- find 연산** : 특정 노드 a에 관해 a가 속한 집합의 대표 노드를 반환하는 연산이다. 노드 a가 a $\in$ A일 때 find(a)는 A 집합의 대표 노드를 반환한다.

</aside>

> **유니온 파인드의 원리 이해하기**
> 
1. **초기화**
- 1차원 배열 이용
- 처음에는 노드가 연결되어 있지 않으므로 각 노드가 대표 노드가 된다. 배열은 자신의 인덱스 값으로 초기화한다.

<img width="688" alt="Screenshot 2023-08-03 at 14 47 49" src="https://github.com/StopSoo/Stopsoo/assets/114139700/db3efb86-20ef-44c0-9542-470b613e0d41">

>
    - 오른쪽 배열이 대표 노드를 저장하는 배열. 

2. **Union**
- 2개의 노드를 선택해 각각의 대표 노드를 찾아 연결하는 union 연산을 수행한다.
<img width="671" alt="Screenshot 2023-08-03 at 14 49 41" src="https://github.com/StopSoo/Stopsoo/assets/114139700/3ab49874-2ab7-49d1-be6b-2bd07b5d404a">

>
    - 여기서는 값이 작은 노드를 대표 노드로 설정한 것. 
    
3. **Find**
- 자신이 속한 집합의 대표 노드를 찾는 연산
- but, 단순히 대표 노드를 찾는 역할만 하는 것이 아니라 그래프를 정돈하고 시간 복잡도를 향상시킨다.

<aside>
  
💡  **find 연산의 작동 원리**

>  
1️⃣ 대상 노드 배열에 Index 값과 value 값이 동일한지 확인한다.
>
—> 동일하면 그 노드가 대표 노드 !
>
2️⃣ 동일하지 않으면 value 값이 가리키는 index 위치로 이동한다.
>
3️⃣ 이동 위치의 index 값과 value 값이 같을 때까지 (대표노드를 찾을 때까지) 1️⃣~2️⃣를 반복한다. 반복이므로 이 부분은 **재귀 함수로 구현**한다.
>
4️⃣ 대표 노드에 도달하면 재귀 함수를 빠져나오면서 거치는 모든 노드 값을 루트 노드 값으로 변경한다.
>

</aside>

<img width="749" alt="Screenshot 2023-08-03 at 15 01 18" src="https://github.com/StopSoo/Stopsoo/assets/114139700/74c1afde-0647-4799-9fd9-cd837739d29a">

- find 연산을 통해 위 그래프를 아래와 같이 바꿀 경우, 연산을 할 때 다른 노드들을 거치는 형태에서 대표 노드와 바로 연결되는 형태로 변경되는 것을 알 수 있다. 이렇게 되면 추후 노드와 관련된 find 연산 속도가 $O(1)$로 변경된다.

<img width="715" alt="Screenshot 2023-08-03 at 15 04 43" src="https://github.com/StopSoo/Stopsoo/assets/114139700/16ee34fb-954e-4b15-a65c-85a5c119cbc1">

- **경로 압축**은 실제 그래프에서 여러 노드를 거쳐야 하는 경로에서 그래프를 변형해 더 짧은 경로로 갈 수 있도록 함으로써 시간 복잡도를 효과적으로 줄이는 방법을 말한다.

### 위상 정렬 (Topological Sort)

> **위상 정렬**
> 
- 사이클이 없는 방향 그래프에서 노드 순서를 찾는 알고리즘
- 기능 : 노드 간의 순서를 결정
- 특징 : 사이클이 없어야 함 ⭐️
- 시간 복잡도 : 노드 수를 V, 에지 수를 E라고 할 때 $O(V+E)$이다.
- 항상 유일한 값으로 정렬되는 것은 아니다.

> **위상 정렬의 핵심 이론**
> 
1. **진입 차수 배열 만들기**
<img width="685" alt="Screenshot 2023-08-05 at 16 20 21" src="https://github.com/StopSoo/Stopsoo/assets/114139700/64371f0a-a2eb-496d-b184-5bd11fc4dc9e">


2. **정렬하기**

<img width="664" alt="Screenshot 2023-08-05 at 16 23 24" src="https://github.com/StopSoo/Stopsoo/assets/114139700/d2eb6a6f-b165-4db6-bcc4-876616d6669f">

<img width="664" alt="Screenshot 2023-08-05 at 16 26 23" src="https://github.com/StopSoo/Stopsoo/assets/114139700/f04040e2-94f5-41c2-8523-03f052d16130">

>
- 진입 차수 배열의 모든 원소 값이 0이 되었다는 건 정렬이 끝났다는 것 !

### 다익스트라 (Dijkstra)

> **다익스트라 알고리즘**
> 
- 그래프에서 최단 거리를 구하는 알고리즘.
- 기능 : 출발 노드와 모든 노드 간의 최단  거리를 탐색
- 특징 : 에지는 모두 양수
- 시간 복잡도 : 노드 수를 V, 에지 수를 E라고 했을 때 시간 복잡도는 $O(ElogV)$이다.

> **다익스트라 알고리즘의 핵심 이론**
> 
1. **인접 리스트로 그래프 구현하기** 
    
<img width="672" alt="Screenshot 2023-08-05 at 16 32 11" src="https://github.com/StopSoo/Stopsoo/assets/114139700/2d7940ed-c40e-42c0-9e3f-8c0620c974d9">
    
- 다익스트라 알고리즘은 인접 행렬로 구현해도 좋지만, 시간 복잡도 측면에서 N의 크기가 클 것을 대비해 인접 리스트로 구현하는 것이 좋다.
    - N의 크기가 너무 크다면 인접 행렬 선언이 불가능하기 때문 !
- 그래프의 연결을 표현하기 위해 인접 리스트에 연결한 배열의 자료형은 (노드, 가중치)와 같은 형태로 선언하여 연결한다.

2. **최단 거리 배열 초기화하기** 
    
<img width="809" alt="Screenshot 2023-08-05 at 16 36 59" src="https://github.com/StopSoo/Stopsoo/assets/114139700/8693039e-13d3-43a3-89bc-fd40318b6f23">
    

3. **값이 가장 작은 노드 고르기 ⭐️**
    
<img width="809" alt="Screenshot 2023-08-05 at 16 38 51" src="https://github.com/StopSoo/Stopsoo/assets/114139700/294ab38d-3db4-43de-8065-addcc01625f0">


4. **최단 거리 배열 업데이트하기 ⭐️**
- 선택된 노드에 연결된 에지의 값을 바탕으로 다른 노드의 값을 업데이트한다. 1단계에서 저장해놓은 연결 리스트를 이용해 현재 선택된 노드의 에지들을 탐색하고 업데이트하면 된다.
- 연결 노드의 최단 거리는 다음과 같이 두 값 중 더 작은 값으로 업데이트한다.

<aside>
  
💡 **최단 거리 업데이트 방법**
>
Min(선택 노드의 최단 거리 배열의 값 + 에지 가중치, 연결 노드의 최단 거리 배열의 값)

</aside>

5. **과정 3 ~ 4를 반복해 최단 거리 배열 완성하기** 

<img width="728" alt="Screenshot 2023-08-05 at 16 44 36" src="https://github.com/StopSoo/Stopsoo/assets/114139700/02ff6a74-40f0-4b1d-a89e-2aa346f5ff6a">

- 과정 4에서 선택 노드가 될 때마다 다시 선택되지 않도록 방문 배열을 만들어 처리하고, 모든 노드가 선택될 때까지 반복하면 최단 거리 배열이 완성된다.

### [다익스트라 실전 문제] 최단 경로 구하기 (백준 1753)

**Q. 방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.**

➡️ 여기서 포인트는 가중치가 10 이하의 자연수라는 것 = 양수 에지를 말하는 것 !

➡️ 시작점과 다른 노드와 관련된 최단 거리를 구하는 방법으로는 다익스트라 알고리즘과 벨만포드 알고리즘이 있는데, ‘양수 에지’라는 포인트를 통해 다익스트라 알고리즘으로 푸는 것임을 알 수 있다. 

> **풀이 과정**
> 
1.  인접 리스트에 노드를 저장하고 거리 리스트를 초기화한다. 거리 리스트는 앞에서 설명했듯이 출발 노드는 0, 나머지는 무한으로 초기화한다. 

<img width="509" alt="Screenshot 2023-08-05 at 20 37 15" src="https://github.com/StopSoo/Stopsoo/assets/114139700/246376b2-dc8e-4808-a98e-79c6ca3e1359">

2. 최초 시작점을 우선 순위 큐에 삽입하고, 다음 과정에 따라 다익스트라 알고리즘을 수행한다. 

<aside>
  
💡 **다익스트라 알고리즘 수행 과정**
>
1️⃣ 거리 리스트에서 아직 방문하지 않은 노드 중 현재 값이 가장 작은 노드를 선택한다. 즉, 우선 순위 큐에서 데이터를 뽑아온다.
>
- 우선 순위 큐를 사용하는 이유는 현재 값이 가장 작은 노드를 자동으로 뽑아주기 때문 !
>
2️⃣ 해당 노드와 연결된 노드들의 최단 거리값을 다음 공식을 이용해 업데이트한다.
>
- [연결 노드 거리 리스트 값]보다 [선택 노드의 거리 리스트 값 + 에지 가중치]가 더 작은 경우 업데이트 수행
- 업데이트가 수행되는 경우 연결 노드를 우선 순위 큐에 삽입
>
3️⃣ 큐가 빌 때까지 1️⃣~2️⃣를 반복한다.

<img width="544" alt="Screenshot 2023-08-05 at 20 41 29" src="https://github.com/StopSoo/Stopsoo/assets/114139700/e22cba67-98ad-4180-a0d8-63728f0ff147">

</aside>

### 벨만-포드 (Bellman-Ford)

### [벨만-포드 실전 문제] 타임머신으로 빨리 가기 (백준 11657)

### 플로이드-워셜 (Floyd-Warshall)

> **플로이드-워셜**
> 
- 그래프에서 최단 거리를 구하는 알고리즘
- 모든 노드 간에 최단 경로를 탐색한다.
- 음수 가중치 에지가 있어도 알고리즘을 수행할 수 있다.
- 동적 계획법의 원리를 이용해서 알고리즘에 접근한다.
- 시간 복잡도 : $O(V^3)$
    - 3중 for문을 이용하기 때문에 이와 같은 시간 복잡도가 나온다.
    - V가 터무니 없이 큰 게 아니라면 플로이드-워셜 알고리즘을 사용하는 것을 고민해 볼 필요가 있다 !
    - 따라서 플로이드-워셜 알고리즘을 사용해서 푸는 문제는 노드의 개수가 다른 알고리즘을 사용하는 문제보다 현저히 작은 것을 확인할 수 있다 ❗️

> **플로이드-워셜의 핵심 이론**
> 

<img width="718" alt="Screenshot 2023-08-10 at 13 11 33" src="https://github.com/StopSoo/Stopsoo/assets/114139700/7f59c360-15bd-438a-acbd-6ee37f8490ce">

- **“전체의 최단 경로는 부분의 최단 경로가 연결되어 만들어지는 것이다.”**
- A 노드에서 B 노드까지 최단 경로를 구했다고 가정했을 때 최단 경로 위에 K 노드가 존재한다면 그것을 이루는 부분 경로 역시 최단 경로이다.
- Ex> 색칠된 에지 경로가 1 ➡️ 5 최단 경로라면 1 ➡️ 4 최단 경로와 4 ➡️ 5 최단 경로 역시 색칠된 에지로 이뤄질 수 밖에 없다. 이 원리로 다음과 같은 점화식을 도출할 수 있다.

<aside>
  
💡  $D[S][E] = Math.min(D[S][E], \space D[S][K] + D[K][E])$

>
</aside>

> **플로이드-워셜 구현 방법**
> 
1. **리스트를 선언하고 초기화하기**

<img width="781" alt="Screenshot 2023-08-10 at 13 18 16" src="https://github.com/StopSoo/Stopsoo/assets/114139700/4228f450-f52c-411f-bdfb-7f8deb9bec68">

- D[S][E]는 노드 S에서 노드 E까지의 최단 거리를 저장하는 리스트라 정의한다. S와 E의 값이 다른 칸은 0, 다른 칸은  $\infin$ 로 초기화한다.
    - 여기에서 S == E인 부분은 자기 자신에게 가는 데 걸리는 최단 경로 값이므로 0인 것 !
2. **최단 거리 리스트에 데이터 저장하기** 

<img width="781" alt="Screenshot 2023-08-10 at 13 21 15" src="https://github.com/StopSoo/Stopsoo/assets/114139700/d664be7d-e59f-424c-b19f-1e43a47321a7">

- 출발 노드는 S, 도착 노드는 E, 이 에지의 가중치는 W라고 했을 때 D[S][E] = W로 에지의 정보를 리스트에 입력한다. 이로써 플로이드-워셜 알고리즘은 그래프를 인접 행렬로 표현한다는 것을 알 수 있다.
3. **점화식으로 리스트 업데이트하기** 

<img width="817" alt="Screenshot 2023-08-10 at 13 24 57" src="https://github.com/StopSoo/Stopsoo/assets/114139700/cde499ae-c851-4560-9321-e928d45277e1">

가장 바깥쪽 변수가 K임이 포인트 !!! ⭐️

- 3중 for문이 모두 끝나고 나면 인접 행렬은 모든 노드들의 쌍에 대해 최단 거리를 표현하게 된다.

### [플로이드-워셜 실전 문제] 가장 빠른 버스 노선 구하기 (백준 11404)

<aside>
  
💡 **문제를 읽으면서 어떤 알고리즘으로 풀어야 하는지 Hint 찾기 !** 
>
1. 노드의 개수가 최대 100개이다. ➡️ 보통 알고리즘 문제들보다 현저히 작은 편
>
2. 출발-도착 노드만이 아닌, **모든 노드 간 이동**에 대해 필요한 비용의 최솟값을 구한다.
>
3. 입력 형태가 출발 도시, 도착 도시, 필요한 비용이므로 전형적인 그래프 문제라고 볼 수 있다.

</aside>

❗️ 문제에서 **‘시작 도시와 도착 도시를 연결하는 노선은 1개가 아닐 수 있다’** 라고 한 부분에 주의하자 ❗️

<img width="764" alt="Screenshot 2023-08-10 at 14 04 38" src="https://github.com/StopSoo/Stopsoo/assets/114139700/e0f664cc-5402-413d-beed-329873ce9a04">

### 최소 신장 트리 (MST)

- 대표적인 알고리즘 : 크루스칼 알고리즘 / 프림 알고리즘

> **최소 신장 트리 (Minimum Spanning Tree)**
> 
- 그래프에서 모든 노드를 연결할 때 사용된 에지들의 가중치의 합을 최소로 하는 트리

<aside>
  
💡 **최소 신장 트리의 특징**
- 사이클이 포함되면 가중치의 합이 최소가 될 수 없으므로 사이클을 포함하지 않는다. 
- N개의 노드가 있으면 최소 신장 트리를 구성하는 에지의 개수는 항상 N-1개이다.

</aside>

- **포인트 ❗️** 에지 리스트 구현 & 유니온 파인드 알고리즘 사용

> **최소 신장 트리의 핵심 이론**
> 
1. **에지 리스트로 그래프를 구현하고 유니온 파인드 리스트 초기화하기** 

<img width="764" alt="Screenshot 2023-08-10 at 14 23 47" src="https://github.com/StopSoo/Stopsoo/assets/114139700/122777d5-3f14-4097-89c9-a187aa6c80d6">

- 최소 신장 트리는 데이터를 노드가 아닌 에지 중심으로 저장하므로, 인접 리스트가 아닌 에지 리스트의 형태로 저장한다.
    - 이 리스트는 일반적으로 노드 변수 2개와 가중치 변수로 구성된다.
- 사이클 처리를 위한 유니온 파인드 리스트도 함께 초기화한다. 리스트의 인덱스를 해당 자리의 값으로 초기화하면 된다.

2. **그래프 데이터를 가중치 기준으로 정렬하기**

<img width="764" alt="Screenshot 2023-08-10 at 14 29 08" src="https://github.com/StopSoo/Stopsoo/assets/114139700/30334c0a-06e1-4b4f-b0d9-73a482ffa182">

- 에지 리스트에 담긴 그래프 데이터를 가중치 기준으로 오름차순 정렬한다.

3. **가중치가 낮은 에지부터 연결 시도하기** 

<img width="764" alt="Screenshot 2023-08-10 at 14 31 24" src="https://github.com/StopSoo/Stopsoo/assets/114139700/236749ad-562f-4642-b2b6-8b704f99b08c">

- 가중치가 낮은 에지부터 차례대로 **연결을 시도**한다.
    - 사이클이 생기는지 체크하기 ➡️ 연결했을 때 사이클이 생기지 않는 경우만 연결 !

4. **과정 3 반복하기** 

<img width="764" alt="Untitled" src="https://github.com/StopSoo/Stopsoo/assets/114139700/1da0d261-d5aa-4959-90ab-ed33957c7f8b">

> 
- 이 때 유니온파인드 알고리즘 사용 !

5. **총 에지 비용 출력하기**

<img width="764" alt="Screenshot 2023-08-10 at 14 36 43" src="https://github.com/StopSoo/Stopsoo/assets/114139700/4804fff4-3c8c-4765-bb7a-9bc43643d37a">

- 가중치를 모두 더해주면 총 에지 비용이 나온다.

>

<aside>
💡 최소 신장 트리는 에지를 기준으로 하는 알고리즘이기 때문에, 다른 그래프 알고리즘과는 달리 에지 리스트의 형태를 이용해 데이터를 담는다는 특징이 있다.

</aside>
