### 배열과 리스트

> **배열 (array)**
> 
- 메모리의 연속 공간에 값이 채워져 있는 형태의 자료 구조.
- 배열의 값은 인덱스를 통해 참조. 바로 접근 가능.
- 새로운 값을 삽입하거나 특정 인덱스에 있는 값을 삭제하기 어려움.
- 한 번 선언하면 크기를 늘리거나 줄일 수 없음.

> **리스트 (list)**
> 
- 값과 포인터를 묶은 노드를 포인터로 연결한 자료 구조.
- 인덱스가 없어 값에 접근하려면 head 포인터부터 순서대로 접근해야 함. 값에 접근하는 속도가 느림.
- 크기가 정해져 있지 않아, 크기가 변하기 쉬운 데이터를 다룰 때 적절.
- 배열보다 구조가 복잡.

💡 **파이썬에서는 배열과 리스트를 구분하지 않는다 !** 
파이썬의 리스트는 리스트의 특징과 배열의 특징을 모두 가지도록 구현되었다.
>
➡️ index로 값에 바로 접근 가능 / 가변적
>

### [배열과 리스트 실전 문제] 숫자의 합 구하기 (백준 11720)

> **내 풀이**
> 

입력 받은 숫자는 문자열이므로 인덱스를 이용하여 합을 구한다.

> **해설 풀이**
> 

주어진 숫자를 리스트의 형태로 저장한 뒤 해당 리스트를 인덱스를 이용해 탐색하면서 합을 구한다. 


💡 **파이썬에서의 형 변환**
> int 형 변환 : int(data)
> 
> float 형 변환 : float(data)
> 
> 위와 같은 형태로 형 변환 가능 !

### 구간 합

> **구간 합이란 ?**
> 
- 합 배열을 이용하여 시간 복잡도를 더 줄이기 위해 사용하는 특수한 목적의 알고리즘

> **합 배열**
> 
- 배열 A가 있을 때 합 배열 S의 정의

$S[i] = A[0] + A[1] + ... + A[i-1] + A[i]$

- 합 배열 S를 만드는 공식

$S[i] = S[i-1] + A[i]$

- 구간 합을 구하는 공식

$S[j] - S[i-1]$         // i에서 j까지의 구간 합

### [구간 합 실전 문제] 구간 합 구하기 2 (백준 11660)


💡 표의 크기 N은 그렇게 크진 않지만, 질의의 개수인 M이 100,000과 같이 큰 경우, 정답판(구간 합 배열)을 만들어 놓고 질의가 오면 바로 답을 출력하는 형태로 풀어야 하는 건 아닌지 생각해봐야 한다 !

💡 **2차원 구간의 합을 구할 수 있는지 없는지가 핵심 !!**

<img width="885" alt="Screenshot 2023-07-20 at 11 14 19" src="https://github.com/StopSoo/Stopsoo/assets/114139700/d16c1354-4cec-4014-8978-e1343683ae21">
<img width="885" alt="Screenshot 2023-07-20 at 11 13 27" src="https://github.com/StopSoo/Stopsoo/assets/114139700/75020603-baca-4c7b-9645-1c17ede1488b">
<img width="874" alt="Screenshot 2023-07-20 at 11 19 23" src="https://github.com/StopSoo/Stopsoo/assets/114139700/e60e43e4-0765-475c-932c-d86419b61fb0">
<img width="874" alt="Screenshot 2023-07-20 at 11 19 58" src="https://github.com/StopSoo/Stopsoo/assets/114139700/5a243c54-bb4f-4b5b-a09c-4179d4b40061">


> **질의 X1, Y1, X2, Y2에 대한 답을 구간 합으로 구하는 방법**
> 

$D[X2][Y2] - D[X1-1][Y2] - D[X2][Y1-1] + D[X1-1][Y1-1]$
<img width="874" alt="Screenshot 2023-07-20 at 11 23 28" src="https://github.com/StopSoo/Stopsoo/assets/114139700/7c9027c5-bc12-4793-afc3-03abb5a23030">


### [구간 합 실전 문제] 나머지 합 구하기 (백준 10986) ⭐️

💡 이 문제의 포인트는 **어떻게 하면 시간 복잡도를 줄일 수 있는가** !
>
💡 **나머지 합 문제 풀이의 핵심 아이디어** (어려움!)
>
**1.** (A+B) % C 🟰 ((A%C) + (B%C)) % C
>
➡️ 특정 구간 수들의 나머지 연산을 더해 나머지 연산을 한 값과 이 구간 합의 나머지 연산을 한 값은 동일하다. 
>
**2.** 구간 합 배열을 이용한 식 S[i] - S[j]은 원본 리스트의 j+1부터 i까지의 구간 합이다.
>
**3.** S[i] % M의 값과 S[j] % M의 값이 같다면 (S[i] - S[j]) % M은 0이다. 즉, 구간 합 배열의 원소를 M으로 나눈 나머지로 업데이트하고, S[i]와 S[j]가 같은 (i, j) 쌍을 찾으면 원본 리스트에서 j+1부터 i까지의 구간 합이 M으로 나누어떨어진다는 것을 알 수 있다.


1. 합 배열을 구한다.
2. 합 배열의 각 원소들을 나누는 수로 나눠 나머지들로 업데이트한다.
3. 값이 같은 원소들끼리 분류해서 계산한다.

Ex> 0인 것들이 3개, 1인 것들이 2개
- 여기서 변경된 합 배열의 원소 값이 0이라는 뜻은 원본 리스트의 0부터 i까지의 구간 합이 이미 M으로 나누어 떨어진다는 뜻이므로 경우의 수에 3을 더해준다.
- $3C2 = 3, 2C2 = 1$ ➡️ 4를 경우에 수에 더해준다.

**A. 7개**

<img width="666" alt="Screenshot 2023-07-21 at 14 11 50" src="https://github.com/StopSoo/Stopsoo/assets/114139700/39831a62-8c9f-4ed1-874e-338475e6f98a">

### [슬라이딩 윈도우 실전 문제] 10 최솟값 찾기 1 (백준 11003)

➡️ 나중에 풀고 다시 공부하기 !!

### 스택과 큐

> **스택 (Stack)**
> 
- 삽입과 삭제 연산이 후입선출(LIFO: Last-in First-out)로 이뤄지는 자료구조.
- 새 값이 스택에 들어가면 top이 새 값을 가리킨다.
스택에서 값을 빼낼 때 pop은 top이 가리키는 값을 스택에서 빼게 되어 있으므로 결과적으로는 가장 마지막에 넣었던 값이 나오게 된다.
- Push → append / Pop


>
       s.append(data) : top 위치에 새로운 데이터를 삽입하는 연산
       s.pop() : top 위치에 현재 있는 데이터를 삭제하고 확인하는 연산
       s[-1] : top 위치에 현재 있는 데이터를 단순 확인하는 연산
>
- 깊이 우선 탐색(DFS: Depth First Search), 백트래킹 종류의 코딩 테스트에 효과적이다. 후입선출은 개념 자체가 재귀 함수 알고리즘 원리와 일맥상통하기 때문.

> **큐 (Queue)**
> 
- 삽입과 삭제 연산이 선입선출(FIFO: First-in First-out)로 이뤄지는 자료구조.
- 스택과 다르게 먼저 들어온 데이터가 먼저 나간다. 삽입과 삭제가 양방향에서 이뤄진다. 새 값 추가는 큐의 rear에서 이뤄지고, 삭제는 큐의 front에서 이뤄진다.
- 파이썬에서는 일반적으로 deque를 이용하여 큐를 구현한다.
- 위치
>
      rear : 큐에서 가장 끝 데이터를 가리키는 영역
      front : 큐에서 가장 앞 데이터를 가리키는 영역
>
- 연산

>
       s.append(data) : rear 부분에 새로운 데이터를 삽입하는 연산
       s.popleft() : front 부분에 있는 데이터를 삭제하고 확인하는 연산
       s[0] : 큐의 맨 앞(front)에 있는 데이터를 확인할 때 사용하는 연산
>
- 너비 우선 탐색 (BFS: Breadth First Search)에서 자주 사용한다.


💡 **우선 순위 큐(priority queue)**
우선 순위 큐는 값이 들어간 순서와 상관 없이 우선 순위가 높은 데이터가 먼저 나오는 자료구조이다. 큐 설정에 따라 front에 항상 최댓값 또는 최솟값이 위치한다. 우선 순위 큐는 일반적으로 힙을 이용해 구현한다.


### [스택과 큐 실전 문제] 12 오큰수 구하기 (백준 17928)

💡 주어진 리스트의 역순으로 생각하면서 나를 오큰수로 가질 만한 수가 뭐가 있는지 생각해본다던가 … 여러 가지 방법이 있을 수 있다.


💡 **오큰수 구하기 문제의 핵심 아이디어 ⭐️**
>
➡️ 스택이라는 것을 생각하기가 어려움 !
>
**1.** 스택에 새로 들어오는 수가 top에 존재하는 수보다 크면 그 수는 오큰수가 된다.
>
**2.** 오큰수를 구한 후 수열에서 오큰수가 존재하지 않는 숫자에 -1을 출력해야 한다.
>

> **문제 푸는 순서**
> 
1. 스택이 채워져 있고 A[index] > A[top]인 경우 pop한 인덱스를 이용하여 정답 수열에 오큰수를 저장한다. pop은 조건을 만족하는 동안 계속 반복한다. 과정 1을 마치면 과정 2로 넘어간다. 
2. 현재 인덱스를 스택에 push(append)하고 다음 인덱스로 넘어간다.
➡️ 값이 아니라 인덱스를 스택에 넣는다는 게 포인트 ! ⭐️
3. 과정 1 ~ 2를 수열 길이 만큼 반복한 다음 현재 스택에 남아 있는 인덱스에 -1을 저장한다. 

<img width="791" alt="Screenshot 2023-07-22 at 20 52 04" src="https://github.com/StopSoo/Stopsoo/assets/114139700/db909d47-e7e5-48a9-85cd-5c16ff80b06c">

>
>
➡️ 인덱스 1이 들어 오고 난 후 인덱스 0 원소를 빼냄으로써 시간 복잡도가 감소한다.
>

✏️ 인덱스 0을 push(append)하고 다음 인덱스로 넘어간다. A[1]은 5이고 A[top]은 3이므로 스택에서 pop을 수행하고 Result[0]에 오큰수 5를 저장한다. 1회 반복으로 스택이 비었으므로 pop은 더 이상 진행하지 않는다. 인덱스 1을 push(append)하고 다음 인덱스로 넘어간다. A[2]는 2이고 A[top]은 5이므로 과정 2를 진행하여 push(append)하고 다음 인덱스로 넘어간다. A[2]는 2이고 A[top]은 5이므로 과정 2를 진행하여 push(append)하고 다음 인덱스로 넘어간다. 이 과정을 수열의 길이 만큼 반복한 후 스택에 남아 있는 index에 -1을 저장하면 정답 배열을 완성할 수 있다.
