### 트리 알아보기

- 트리는 노드와 에지로 연결된 그래프의 특수한 형태
- 그래프의 표현으로도 트리를 표현할 수 있다.

> **트리의 특징**
> 
- 순환 구조를 지니고 있지 않고, 1개의 루트 노드가 존재한다.
- 루트 노드를 제외한 노드는 단 1개의 부모 노드를 갖는다.
- 트리의 부분 트리 역시 트리의 모든 특징을 따른다.
- 연결되어 있는 트리에서 임의의 두 노드를 이어주는 경로는 유일하다.

> **트리의 핵심 이론**
> 

<img width="544" alt="Screenshot 2023-10-14 at 15 57 58" src="https://github.com/StopSoo/Stopsoo/assets/114139700/7afe1115-96a6-44fc-b453-3bd57004528f">

<img width="777" alt="Screenshot 2023-10-14 at 15 59 15" src="https://github.com/StopSoo/Stopsoo/assets/114139700/9cee4244-7595-4fc2-8939-2eab09e8b3bc">

>
>

<aside>
  
💡 **코딩 테스트에서 tree 🌲**
>
1️⃣ 그래프로 푸는 트리
>
—> 노드와 에지 사이의 관계를 인접 리스트로 표현
>
—> DFS, BFS 이용해서 해결
>
2️⃣ 트리만을 위한 문제
>
—> 이진 트리 | 세그먼트 트리 | LCA  **(어려움!)**
>

</aside>

### 이진 트리

- 각 노의 자식 노드(차수)의 개수가 2 이하로 구성된 트리
- 트리 영역에서 가장 많이 사용되는 형태

> **이진 트리의 종류**
> 

<img width="777" alt="Screenshot 2023-10-16 at 12 13 05" src="https://github.com/StopSoo/Stopsoo/assets/114139700/1493fc4c-c642-4709-8c70-468f4c4cefa5">

>
- 편향 이진 트리 : 노드들이 한 쪽으로 편향돼 생성된 이진 트리
>
- 포화 이진 트리 : 트리의 높이가 모두 일정하며 리프 노드가 꽉 찬 이진 트리
>
- 완전 이진 트리 : 마지막 레벨을 제외하고 완전하게 노드들이 채워져 있고, 마지막 레벨은 왼쪽부터 채워진 트리
>

<aside>
💡 1. 데이터를 트리 자료 구조에 저장할 때 편향 이진 트리의 형태로 저장하면 탐색 속도가 저하되고 공간이 많이 낭비되는 단점이 있다.
  
>
   ➡️ 일반적으로 코딩 테스트에서 데이터를 트리에 담는다고 하면 완전 이진 트리 형태를 떠올리면 된다 !
>

2. 이진 트리를 순차적으로 표현하기에 가장 직관적이면서 편리한 형태는 **‘배열’** 이다.
>

</aside>

> **이진 트리의 순차 표현**
> 

<img width="632" alt="Screenshot 2023-10-16 at 12 17 23" src="https://github.com/StopSoo/Stopsoo/assets/114139700/e250b37a-beb6-4ddb-99fc-06e0739fade2">

<img width="720" alt="Screenshot 2023-10-16 at 12 20 46" src="https://github.com/StopSoo/Stopsoo/assets/114139700/dc98545a-b82e-43d8-b77a-164f0c344edc">

### LCA (최소 공통 조상)

- 트리에서 임의의 두 노드를 선택했을 때 두 노드가 각각 자신을 퐇마해 거슬러 올라가면서 부모 노드를 탐색할 때 처음 공통으로 만나게 되는 부모 노드를 **최소 공통 조상(Lowest Common Ancestor)** 이라고 한다.

> **LCA의 핵심 이론**
> 
- 일반적인 최소 공통 조상 구하기
    - 트리의 높이가 크지 않을 때 최소 공통 조상을 구하는 방법
     >
    ➡️ 먼저 루트 노드에서 탐색을 시작해 각 노드의 부모 노드와 깊이를 저장한다.
     >
    ➡️ 이 때 탐색은 DFS 또는 BFS를 이용해 수행한다.

  <img width="778" alt="Screenshot 2023-10-16 at 12 26 33" src="https://github.com/StopSoo/Stopsoo/assets/114139700/e7347407-b232-49d2-a6f4-70bcdabe0f3f">

        
    - 선택된 두 노드의 길이가 다른 경우, 더 깊은 노드의 노드를 부모 노드로 1개씩 올려 주면서 같은 길이로 맞춘다. 이 때 두 노드가 같으면 해당 노드가 최소 공통 조상이므로 탐색을 종료한다.
        
  <img width="815" alt="Screenshot 2023-10-16 at 12 36 05" src="https://github.com/StopSoo/Stopsoo/assets/114139700/842c429c-863f-42d3-8d23-8bc9b2ac5844">

        
    - 깊이가 같은 상태에서는 동시에 부모 노드로 올라가면서 두 노드가 같은 노드가 될 때까지 반복한다. 이 때 처음 만나는 노드가 최소 공통 조상이 된다. 이러한 원리로 다음 트리에서 4번, 15번 노드의 최소 공통 부모는 1이 된다.
        
  <img width="815" alt="Screenshot 2023-10-16 at 12 37 25" src="https://github.com/StopSoo/Stopsoo/assets/114139700/94cce8c8-729e-4edb-baa4-68e85204b645">

>

<aside>
💡 위와 같은 방식을 이용하면 최소 공통 조상을 구할 수 있지만, 트리의 높이가 커질 경우 시간 제약 문제에 직면할 수 있다.  

  >

💡 이런 문제를 해결하기 위해 새롭게 제안된 방식이 ‘최소 공통 조상 빠르게 구하기’이다. ‘최소 공통 조상 빠르게 구하기’는 일반적인 최소 공통 조상 구하기 알고리즘을 약간 변형한 형태이다.

</aside>
