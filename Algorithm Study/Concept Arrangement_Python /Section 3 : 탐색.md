### DFS (깊이 우선 탐색)

> **깊이 우선 탐색**
> 
- 그래프 완전 탐색 기법 중 하나로, 그래프 내 모든 노드를 탐색한다.
- 그래프의 시작 노드에서 출발하여 탐색할 한 쪽 분기를 정하여 최대 깊이까지 탐색을 마친 후 다른 쪽 분기로 이동하여 다시 탐색을 수행하는 알고리즘이다.
- 재귀 함수로 구현하고, 자료구조 중 스택을 사용한다. ➡️ LIFO 탐색 ⭐️
- 시간 복잡도는 노드 수를 $V$ , 엣지 수를 $E$  라고 할 때 $O(V+E)$  이다.
- 깊이 우선 탐색은 실제 구현 시 재귀 함수를 이용하므로 **스택 오버플로(stack overflow)** 에 유의해야 한다.
- DFS를 응용하여 풀 수 있는 문제는 단절점 찾기, 단절선 찾기, 사이클 찾기, 위상 정렬 등이 있다.

> **깊이 우선 탐색의 핵심 이론**
> 
- 한 번 방문한 노드를 다시 방문하면 안 되므로 노드 방문 여부를 체크할 배열이 필요하며, 그래프는 인접 리스트로 표현한다.
- DFS의 탐색 방식은 후입선출(LIFO) 특성을 가지므로 스택을 사용한다. 
    - 하지만 DFS 구현은 스택보다는 스택 성질을 갖는 재귀 함수로 많이 구현한다.
- 스택에 노드를 삽입할 때 방문 배열을 체크하고, 스택에서 노드를 뺄 때 탐색 순서에 기록하며 인접 노드를 방문 배열과 대조하여 살펴본다.

1. **DFS를 시작할 노드를 정한 후 사용할 자료구조 초기화하기**

DFS를 위해 필요한 초기 작업은 인접 리스트로 그래프 표현하기, 방문 배열 초기화하기, 시작 노드 스택에 삽입하기이다. 스택에 시작 노드를 1로 삽입할 때 해당 위치의 방문 배열을 체크하면 T, F, F, F, F, F가 된다.

<img width="805" alt="Screenshot 2023-07-26 at 16 08 49" src="https://github.com/StopSoo/Stopsoo/assets/114139700/b2c43a75-e599-4e76-a68c-f3201f111ffd">

2. **스택에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 스택에 삽입하기** 

이제 pop을 수행하여 노드를 꺼낸다. 꺼낸 노드를 탐색 순서에 기입하고 인접 리스트의 인접 노드를 스택에 삽입하며 방문 배열을 체크한다. 방문 배열은 T, T, T, F, F, F가 된다.

<img width="805" alt="Screenshot 2023-07-26 at 16 11 48" src="https://github.com/StopSoo/Stopsoo/assets/114139700/41caf92e-fdce-449a-89d4-b5f822fea15d">

3. **스택 자료구조에 값이 없을 때까지 반복하기** 

<img width="852" alt="Screenshot 2023-07-26 at 16 18 11" src="https://github.com/StopSoo/Stopsoo/assets/114139700/4fcd2665-8235-41f0-901b-45031ca381eb">

앞선 과정을 스택 자료구조에 값이 없을 때까지 반복한다. 이 때 이미 다녀간 노드는 방문 배열을 바탕으로 재삽입하지 않는 것이 핵심이다. 

### BFS (너비 우선 탐색)

> **너비 우선 탐색**
> 
- 그래프를 완전 탐색하는 방법 중 하나로, 시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 먼저 방문하면서 탐색하는 알고리즘이다.
- FIFO 탐색⭐️(DFS랑 다른 점 !!)을 이용하고, Queue 자료 구조를 이용한다.
- 시간 복잡도는 노드 수를 $V$ , 엣지 수를 $E$ 라고 할 때 $O(V+E)$이다. **➡️ DFS와 같음 !**
- 탐색 시작 노드와 가까운 노드를 우선하여 탐색하므로 목표 노드에 도착하는 경로가 여러 개일 때 최단 경로를 보장한다. **⭐️⭐️ 매우 중요 !! ⭐️⭐️**

> **너비 우선 탐색의 핵심 이론**
> 
1. **BFS를 시작할 노드를 정한 후 사용할 자료구조 초기화하기** 

BFS도 DFS와 마찬가지로 방문했던 노드는 다시 방문하지 않으므로 방문한 노드를 체크하기 위한 배열이 필요하다. 그래프를 인접 리스트로 표현하는 것 역시 DFS와 동일하다. 하나 차이점이 있다면 탐색을 위해 스택이 아닌 큐를 사용한다는 점이다. 

<img width="793" alt="Screenshot 2023-07-26 at 14 31 55" src="https://github.com/StopSoo/Stopsoo/assets/114139700/da42f2e8-338b-4faf-853f-2f9deddbc7b4">

위 그림은 시작 노드를 큐에 삽입하며 방문 배열을 체크한 것을 보여준다.

2. **큐에서 노드를 꺼낸 후 꺼낸 노드의 인접 노드를 다시 큐에 삽입하기**

큐에서 노드를 꺼내면서 인접 노드를 큐에 삽입한다. 이 때 방문 배열을 체크하여 이미 방문한 노드는 큐에 삽입하지 않는다. 또한 큐에서 꺼낸 노드는 탐색 순서에 기록한다.

<img width="788" alt="Screenshot 2023-07-26 at 14 34 07" src="https://github.com/StopSoo/Stopsoo/assets/114139700/653fa00b-1b7f-4390-b099-57dfbe5c541d">

위 그림의 경우 1을 꺼내며 탐색 순서에 1을 기록하고 인접 노드 3, 2를 큐에 삽입하며 방문 배열에 체크했다.

3. **큐 자료구조에 값이 없을 때까지 반복하기** 

큐에 노드가 없을 때까지 앞선 과정을 반복한다. 선입선출(FIFO) 방식으로 탐색하므로 탐색 순서가 DFS와 다른을 확인해보자.

<img width="788" alt="Screenshot 2023-07-26 at 14 36 37" src="https://github.com/StopSoo/Stopsoo/assets/114139700/61521bed-2a13-412f-b0ef-60ac58a58915">

### 이진 탐색 (Binary Search)

> **이진 탐색**
> 
- **데이터가 정렬되어 있는 상태⭐️**에서 원하는 값을 찾아내는 알고리즘.
- 대상 데이터의 중앙값과 찾고자 하는 값을 비교해 데이터의 크기를 절반씩 줄이면서 대상을 찾는다.
- 시간 복잡도는 $O(nlogn)$  
- 구현 및 원리가 비교적 간단하므로 많은 코딩 테스트에서 부분 문제로 요구하는 영역이다.

> **이진 탐색의 핵심 이론**
> 
- 이진 탐색 과정 (오름차순)
>
➡️ *내림차순이라면 조건을 반대로 하여 과정을 반복하면 된다 !*
>
1. 현재 데이터셋의 **중앙값**을 선택한다. ➡️ 말 그대로 가운데 값 !
>
2. **중앙값 > 타깃 데이터**일 때 중앙값 기준으로 왼쪽 데이터셋을 선택한다.
>
3. **중앙값 < 타깃 데이터**일 때 중앙값 기준으로 오른쪽 데이터셋을 선택한다.
>
4. 과정 1 ~ 3을 반복하다가 **중앙값 == 타깃 데이터**일 때 탐색을 종료한다.
>

<img width="774" alt="Screenshot 2023-07-26 at 14 18 39" src="https://github.com/StopSoo/Stopsoo/assets/114139700/4b80dfee-28af-4535-bc4b-a1069625e7c7">
